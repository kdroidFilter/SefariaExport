name: Sefaria Export (Self-hosted â€¢ Python 3.9 â€¢ ALL exports â†’ branch root)

on:
  workflow_dispatch:
    inputs:
      timezone:
        description: "Timezone for timestamp/tag (IANA name)"
        required: false
        default: "Asia/Jerusalem"

permissions:
  contents: write

concurrency:
  group: sefaria-export-selfhosted
  cancel-in-progress: false

env:
  TZ_NAME: ${{ inputs.timezone || 'Asia/Jerusalem' }}
  DJANGO_SETTINGS_MODULE: sefaria.settings
  MONGO_HOST: 127.0.0.1
  MONGO_PORT: 27017
  MONGO_DB_NAME: sefaria
  SEFARIA_DB: sefaria
  PYTHONDONTWRITEBYTECODE: 1

jobs:
  prep:
    name: Compute timestamp
    runs-on: [self-hosted, Linux, X64]
    outputs:
      stamp: ${{ steps.ts.outputs.stamp }}
    steps:
      - name: Compute release timestamp
        id: ts
        shell: bash
        run: |
          set -euo pipefail
          TZ="${TZ_NAME}" date '+%Y-%m-%d_%H-%M' > ts.txt
          echo "stamp=$(cat ts.txt)" >> "$GITHUB_OUTPUT"
          echo "â± TZ=${TZ_NAME} â†’ $(cat ts.txt)"

  export_and_push:
    name: Run ALL exports and push to date branch (root)
    runs-on: [self-hosted, Linux, X64]
    needs: prep
    env:
      TS_STAMP: ${{ needs.prep.outputs.stamp }}
      STAGING_BASE: ${{ github.workspace }}/staging
      SEFARIA_EXPORT_PATH: ${{ github.workspace }}/staging
    steps:
      - name: Pre-clean Mongo (containers & service)
        shell: bash
        run: |
          set -euo pipefail
          docker ps -aq --filter "name=mongo" | xargs -r docker rm -f || true
          sudo systemctl stop mongod 2>/dev/null || true
          (sudo fuser -k 27017/tcp || true) 2>/dev/null || true

      - name: Checkout .github (sparse)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          ref: main
          sparse-checkout: |
            .github
          sparse-checkout-cone-mode: false

      - name: Ensure base tools (apt) + Python 3.9 + venv
        shell: bash
        run: |
          set -euo pipefail
          if command -v apt-get >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y ca-certificates tar wget rsync netcat-openbsd xz-utils git curl
            sudo apt-get install -y aria2 || true
            sudo apt-get install -y python3.9 python3.9-venv python3.9-distutils
            if ! /usr/bin/python3.9 -m pip -V >/dev/null 2>&1; then
              curl -fsSL https://bootstrap.pypa.io/pip/3.9/get-pip.py -o /tmp/get-pip.py
              /usr/bin/python3.9 /tmp/get-pip.py
            fi
          else
            echo "âŒ This step assumes an APT-based distro. Install Python 3.9 + venv and basic tools manually."
            exit 1
          fi
          echo "âœ… System deps ready."

      - name: Create & activate venv (Python 3.9)
        shell: bash
        run: |
          set -euo pipefail
          /usr/bin/python3.9 -m venv "$GITHUB_WORKSPACE/.venv"
          source "$GITHUB_WORKSPACE/.venv/bin/activate"
          python -V
          pip -V
          pip install --upgrade pip setuptools wheel
          echo "VENV_BIN=$GITHUB_WORKSPACE/.venv/bin" >> "$GITHUB_ENV"

      - name: Install MongoDB Database Tools (mongorestore)
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v mongorestore >/dev/null 2>&1; then
            TOOLS_VER="100.9.4"
            aria2c -x 16 -s 16 -k 1M -o /tmp/mdbtools.tgz "https://fastdl.mongodb.org/tools/db/mongodb-database-tools-ubuntu2204-x86_64-${TOOLS_VER}.tgz" || \
              wget -O /tmp/mdbtools.tgz "https://fastdl.mongodb.org/tools/db/mongodb-database-tools-ubuntu2204-x86_64-${TOOLS_VER}.tgz"
            tar -xzf /tmp/mdbtools.tgz -C /tmp
            sudo mv /tmp/mongodb-database-tools-ubuntu2204-x86_64-${TOOLS_VER}/bin/* /usr/local/bin/
          fi
          mongorestore --version

      - name: Ensure MongoDB is reachable (start if service exists)
        shell: bash
        run: |
          set -euo pipefail
          sudo systemctl start mongod 2>/dev/null || true
          for i in {1..120}; do
            if (echo > /dev/tcp/${MONGO_HOST}/${MONGO_PORT}) >/dev/null 2>&1; then
              echo "âœ… MongoDB reachable at ${MONGO_HOST}:${MONGO_PORT}"
              exit 0
            fi
            echo "â³ Waiting MongoDB ${MONGO_HOST}:${MONGO_PORT}..."; sleep 1
          done
          echo "âŒ Mongo not reachable"; exit 1

      - name: Clone Sefaria-Project
        shell: bash
        run: |
          set -euo pipefail
          git clone --depth 1 https://github.com/Sefaria/Sefaria-Project.git
          ls -la Sefaria-Project | head -n 20

      - name: Prepare Python requirements (skip google-re2, force psycopg2-binary)
        shell: bash
        run: |
          set -euo pipefail
          cd Sefaria-Project
          grep -viE '^\s*google-re2\s*(==|>=|>|<|~=)?' requirements.txt > req-no-re2.txt || true
          sed -i 's/^\s*psycopg2\s*$/psycopg2-binary/g' req-no-re2.txt || true
          sed -i 's/^\s*psycopg2[<>=~].*$/psycopg2-binary/g' req-no-re2.txt || true
          echo "---- effective requirements (without google-re2) ----"
          head -n 80 req-no-re2.txt

      - name: Add re2 shim (compat Options + compile(options=...))
        shell: bash
        run: |
          set -euo pipefail
          cat > Sefaria-Project/re2.py <<'PY'
          """
          Lightweight compatibility shim for 'google-re2' used by Sefaria.
          Provides:
            - Options(): common attributes used by callers
            - compile(pattern, options=None): maps basic fields to Python 're'
          Falls back to stdlib 're' for everything else.
          """
          import re as _re

          class Options:
              __slots__ = (
                  "case_sensitive",
                  "posix_syntax",
                  "longest_match",
                  "log_errors",
                  "max_mem",
                  "literal",
                  "word_boundary",
                  "one_line",
                  "dot_nl",
              )
              def __init__(self):
                  self.case_sensitive = True
                  self.posix_syntax   = False
                  self.longest_match  = False
                  self.log_errors     = False
                  self.max_mem        = None
                  self.literal        = False
                  self.word_boundary  = False
                  self.one_line       = False
                  self.dot_nl         = False
              def __repr__(self):
                  return (f"Options(case_sensitive={self.case_sensitive}, "
                          f"posix_syntax={self.posix_syntax}, longest_match={self.longest_match}, "
                          f"dot_nl={self.dot_nl}, one_line={self.one_line})")

          def compile(pattern, options=None):
              flags = 0
              if options is not None:
                  if getattr(options, "case_sensitive", True) is False:
                      flags |= _re.IGNORECASE
                  if getattr(options, "dot_nl", False):
                      flags |= _re.DOTALL
                  if getattr(options, "one_line", False):
                      flags |= _re.MULTILINE
                  if getattr(options, "literal", False):
                      pattern = _re.escape(pattern)
              return _re.compile(pattern, flags)

          # Common passthroughs
          error     = _re.error
          escape    = _re.escape
          match     = _re.match
          search    = _re.search
          fullmatch = getattr(_re, "fullmatch", None)
          findall   = _re.findall
          finditer  = _re.finditer
          sub       = _re.sub
          subn      = _re.subn
          split     = _re.split
          Pattern   = getattr(_re, "Pattern", None)

          IGNORECASE = _re.IGNORECASE
          MULTILINE  = _re.MULTILINE
          DOTALL     = _re.DOTALL
          VERBOSE    = _re.VERBOSE
          ASCII      = getattr(_re, "ASCII", 0)
          UNICODE    = getattr(_re, "UNICODE", 0)
          PY
          echo "PYTHONPATH=${GITHUB_WORKSPACE}/Sefaria-Project${PYTHONPATH:+:${PYTHONPATH}}" >> "$GITHUB_ENV"

          # Smoke-test rapide
          python - <<'PY'
          import re2
          opt = re2.Options()
          opt.case_sensitive = False
          rx = re2.compile(r"ABC", opt)
          assert rx.search("abc")
          print("âœ… re2 shim OK")
          PY

      - name: Install Python deps into venv
        shell: bash
        run: |
          set -euo pipefail
          source "$GITHUB_WORKSPACE/.venv/bin/activate"
          python -m pip install -U pip setuptools wheel
          python -m pip install -U Cython
          python -m pip install --no-cache-dir -r Sefaria-Project/req-no-re2.txt

      - name: Configure local_settings.py (SEFARIA_DB + export path)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$STAGING_BASE"
          cp Sefaria-Project/sefaria/local_settings_example.py Sefaria-Project/sefaria/local_settings.py
          source "$GITHUB_WORKSPACE/.venv/bin/activate"
          python - <<'PY'
          import os, re
          p = "Sefaria-Project/sefaria/local_settings.py"
          with open(p, "r", encoding="utf-8") as f:
              s = f.read()
          s = re.sub(r"SEFARIA_EXPORT_PATH\s*=.*", f'SEFARIA_EXPORT_PATH = r"{os.environ["STAGING_BASE"]}"', s)
          s = re.sub(r"MONGO_HOST\s*=.*", f'MONGO_HOST = "{os.environ["MONGO_HOST"]}"', s)
          s = re.sub(r"MONGO_PORT\s*=.*", f'MONGO_PORT = {int(os.environ["MONGO_PORT"])}', s)
          s = re.sub(r"MONGO_DB_NAME\s*=.*", f'MONGO_DB_NAME = "{os.environ["MONGO_DB_NAME"]}"', s)
          if re.search(r"SEFARIA_DB\s*=", s):
              s = re.sub(r"SEFARIA_DB\s*=.*", f'SEFARIA_DB = "{os.environ["SEFARIA_DB"]}"', s)
          else:
              s += f'\nSEFARIA_DB = "{os.environ["SEFARIA_DB"]}"\n'
          with open(p, "w", encoding="utf-8") as f:
              f.write(s)
          print("âœ… local_settings.py configured.")
          PY

      - name: Download small Mongo dump
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p mongo_dump
          aria2c -x 16 -s 16 -k 1M -o dump_small.tar.gz "https://storage.googleapis.com/sefaria-mongo-backup/dump_small.tar.gz" \
            || wget -O dump_small.tar.gz "https://storage.googleapis.com/sefaria-mongo-backup/dump_small.tar.gz"
          tar -xzf dump_small.tar.gz -C mongo_dump
          rm -f dump_small.tar.gz || true
          echo "Dump tree:"; find mongo_dump -maxdepth 3 | sed -e 's/^/  /'

      - name: Normalize dump â†’ mongo_dump_pkg/sefaria
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p mongo_dump_pkg
          if [ -d mongo_dump/dump/sefaria ]; then
            cp -a mongo_dump/dump/sefaria mongo_dump_pkg/
          elif [ -d mongo_dump/sefaria ]; then
            cp -a mongo_dump/sefaria mongo_dump_pkg/
          else
            echo "âŒ 'sefaria' folder not found in dump"; exit 1
          fi
          echo "Packaged tree:"; find mongo_dump_pkg -maxdepth 2 | sed -e 's/^/  /'

      - name: Restore DB (skip index restore to avoid long build)
        shell: bash
        run: |
          set -euo pipefail
          mongorestore --host "${MONGO_HOST}" --port "${MONGO_PORT}" \
            --drop --db "${SEFARIA_DB}" --noIndexRestore "mongo_dump_pkg/sefaria"

      - name: Ensure 'history' collection exists
        shell: bash
        run: |
          set -euo pipefail
          source "$GITHUB_WORKSPACE/.venv/bin/activate"
          python - <<'PY'
          from pymongo import MongoClient, errors
          import os
          uri = f"mongodb://{os.environ['MONGO_HOST']}:{os.environ['MONGO_PORT']}"
          client = MongoClient(uri, serverSelectionTimeoutMS=5000)
          db = client[os.environ['SEFARIA_DB']]
          try:
              db.create_collection("history")
              print("Created empty 'history' collection.")
          except errors.CollectionInvalid:
              print("'history' collection already exists.")
          PY

      - name: Run ALL available exports (safe detection)
        shell: bash
        env:
          EXPORT_LIST: export_all,export_all_merged,export_links,export_schemas,export_toc,export_topic_graph,export_texts
        run: |
          set -euo pipefail
          source "$GITHUB_WORKSPACE/.venv/bin/activate"
          export PYTHONPATH="${GITHUB_WORKSPACE}/Sefaria-Project${PYTHONPATH:+:${PYTHONPATH}}"
          python - <<'PY'
          import os, sys, re
          sys.path.insert(0, os.path.abspath("Sefaria-Project"))
          os.environ.setdefault("DJANGO_SETTINGS_MODULE", "sefaria.settings")
          import django; django.setup()
          from sefaria import export as ex

          candidates = [
              "export_all",
              "export_all_merged",
              "export_links",
              "export_schemas",
              "export_toc",
              "export_topic_graph",
              "export_texts",
          ]

          staging_base = os.environ["STAGING_BASE"]
          os.makedirs(staging_base, exist_ok=True)

          def set_export_path(subdir: str):
              p = os.path.join("Sefaria-Project", "sefaria", "local_settings.py")
              with open(p, "r", encoding="utf-8") as f:
                  s = f.read()
              dest = os.path.join(staging_base, subdir)
              os.makedirs(dest, exist_ok=True)
              s = re.sub(r"SEFARIA_EXPORT_PATH\s*=.*", f'SEFARIA_EXPORT_PATH = r"{dest}"', s)
              with open(p, "w", encoding="utf-8") as f:
                  f.write(s)
              print(f"âž¡ï¸  SEFARIA_EXPORT_PATH â†’ {dest}")

          done = []
          for fn in candidates:
              if hasattr(ex, fn):
                  print(f"ðŸš€ Running {fn}()")
                  set_export_path(fn)
                  getattr(ex, fn)()
                  print(f"âœ… {fn} done.")
                  done.append(fn)
              else:
                  print(f"âš ï¸ {fn} not available; skipped.")
          print("âœ” Exports finished:", ", ".join(done))
          PY

      - name: Collect ALL exports into FINAL_DIR (flatten to root)
        shell: bash
        run: |
          set -euo pipefail
          FINAL_DIR="$RUNNER_TEMP/final_root"
          mkdir -p "$FINAL_DIR"
          ORDER="export_all export_all_merged export_links export_schemas export_toc export_topic_graph export_texts"
          for d in $ORDER; do
            SRC="$STAGING_BASE/$d"
            if [ -d "$SRC" ] && [ -n "$(ls -A "$SRC" 2>/dev/null || true)" ]; then
              echo "ðŸ§© Merging $d â†’ FINAL_DIR"
              rsync -a "$SRC/." "$FINAL_DIR/"
            else
              echo "â„¹ï¸  $d empty or missing; skip"
            fi
          done

          echo "---- FINAL_DIR tree (top) ----"
          (cd "$FINAL_DIR" && find . -maxdepth 2 | head -n 200 | sed -e 's/^/  /')

          if [ -z "$(ls -A "$FINAL_DIR")" ]; then
            echo "âŒ FINAL_DIR is empty; nothing to push"; exit 1
          fi

      - name: Push merged exports to date-named branch (root + keep .github) â€” batched & resilient
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BATCH_SIZE: "4000"   # Ajuste la taille des lots si besoin
        shell: bash
        run: |
          set -euo pipefail
          REPO_DIR="$RUNNER_TEMP/pushrepo"
          rm -rf "$REPO_DIR" && mkdir -p "$REPO_DIR"
          git -C "$REPO_DIR" init
          git -C "$REPO_DIR" config user.name "github-actions[bot]"
          git -C "$REPO_DIR" config user.email "github-actions[bot]@users.noreply.github.com"
          git -C "$REPO_DIR" remote add origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"
          TS_BRANCH="${TS_STAMP}"
          git -C "$REPO_DIR" checkout --orphan "$TS_BRANCH"

          # garder workflows
          mkdir -p "$REPO_DIR/.github"
          cp -a "$GITHUB_WORKSPACE/.github/." "$REPO_DIR/.github/"

          # copier les exports Ã  la racine
          FINAL_DIR="$RUNNER_TEMP/final_root"
          cp -a "$FINAL_DIR/." "$REPO_DIR/"

          (cd "$REPO_DIR" && echo "---- Repo root after copy ----" && ls -la | head -n 100)

          # allÃ©ger packs & fiabiliser HTTP
          git -C "$REPO_DIR" config http.version HTTP/1.1
          git -C "$REPO_DIR" config pack.window 0
          git -C "$REPO_DIR" config pack.threads 1
          git -C "$REPO_DIR" config pack.useBitmaps true
          git -C "$REPO_DIR" config pack.packSizeLimit 100m
          git -C "$REPO_DIR" config http.postBuffer 524288000 || true

          retry_push() {
            local tries=6
            local delay=5
            local loc_head="$(git -C "$REPO_DIR" rev-parse HEAD)"
            for i in $(seq 1 $tries); do
              echo "ðŸ” git push attempt $i/$tries ..."
              if git -C "$REPO_DIR" push --force origin HEAD:"$TS_BRANCH"; then
                echo "âœ… Push OK (attempt $i)"
                return 0
              fi
              code=$?
              echo "âŒ Push failed with code $code"
              rem_head="$(git -C "$REPO_DIR" ls-remote --heads origin "$TS_BRANCH" | awk '{print $1}')"
              if [ -n "$rem_head" ] && [ "$rem_head" = "$loc_head" ]; then
                echo "â„¹ï¸ Remote already has our commit ($rem_head). Treat as success."
                return 0
              fi
              git -C "$REPO_DIR" config pack.packSizeLimit 64m
              git -C "$REPO_DIR" repack -adfl --write-bitmap-index || true
              sleep "$delay"
              delay=$(( delay * 2 ))
            done
            return 1
          }

          # Commit & push en lots
          pushd "$REPO_DIR" >/dev/null
          git reset
          i=0
          declare -a buf=()

          # lister uniquement les fichiers non suivis (branche orpheline)
          while IFS= read -r -d '' f; do
            buf+=("$f")
            if (( ${#buf[@]} >= ${BATCH_SIZE} )); then
              git add -- "${buf[@]}"
              echo "Files to commit (batch $((i+1))):"
              git status --porcelain | head -n 200 | sed -e 's/^/  /' || true
              git commit -m "chore(export): batch $((i+1)) at ${TS_STAMP} [skip ci]"
              git gc --prune=now --aggressive || true
              git repack -adfl --write-bitmap-index || true
              retry_push || true
              buf=()
              ((i++))
            fi
          done < <(git ls-files -o --exclude-standard -z)

          # reste
          if (( ${#buf[@]} > 0 )); then
            git add -- "${buf[@]}"
            echo "Files to commit (batch $((i+1))):"
            git status --porcelain | head -n 200 | sed -e 's/^/  /' || true
            git commit -m "chore(export): batch $((i+1)) at ${TS_STAMP} [skip ci]"
            git gc --prune=now --aggressive || true
            git repack -adfl --write-bitmap-index || true
            retry_push || true
          fi

          # ultime vÃ©rif: remote == HEAD local, sinon retente un push
          LOC_HEAD="$(git rev-parse HEAD)"
          REM_HEAD="$(git ls-remote --heads origin "$TS_BRANCH" | awk '{print $1}')"
          if [ "$LOC_HEAD" != "$REM_HEAD" ]; then
            echo "ðŸ”„ Final sync push..."
            retry_push || {
              echo "âŒ Final push failed and remote is not in sync."; exit 1;
            }
          fi
          popd >/dev/null
          echo "âœ… Pushed branch ${TS_BRANCH} (batched)"

      - name: Post-clean Mongo (containers & temp)
        if: always()
        shell: bash
        run: |
          set -e
          docker ps -aq --filter "name=mongo" | xargs -r docker rm -f || true
          sudo systemctl stop mongod 2>/dev/null || true

      - name: Cleanup workspace
        if: always()
        shell: bash
        run: |
          set -e
          rm -rf mongo_dump mongo_dump_pkg Sefaria-Project || true
          rm -rf "$STAGING_BASE" "$RUNNER_TEMP/final_root" || true
          echo "ðŸ§¹ cleanup done."
